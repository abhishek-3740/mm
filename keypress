STM32G071            LCD 16x2
---------------------------------------
PA7 ----------------> RS
PA6 ----------------> RW (or tie to GND)
PA4 ----------------> EN

PB0 ----------------> D0
PB1 ----------------> D1
PB2 ----------------> D2
PB3 ----------------> D3
PB4 ----------------> D4
PB5 ----------------> D5
PB6 ----------------> D6
PB7 ----------------> D7

+5V ----------------> VDD
GND ----------------> VSS

10k POT:
  Left pin ---------> GND
  Middle -----------> VO (Pin 3)
  Right pin --------> +5V


////////////////code /////////////////

#include "stm32g071xx.h"
#include <stdint.h>

void LCD_cmd(uint8_t comd);
void LCD_disp(unsigned char char1);
void msdelay(volatile uint32_t ms);

const char keypad_map[4][4] = {
    {'1', '2', '3', 'A'},
    {'4', '5', '6', 'B'},
    {'7', '8', '9', 'C'},
    {'*', '0', '#', 'D'}
};

int main(void)
{
    uint8_t j;
    uint32_t rowval;
    uint8_t row_index = 0;
    uint8_t col_index = 0;
    char key_char;

    RCC->IOPENR |= 0x00000007;

    GPIOC->MODER &= 0xFFFF00FF;
    GPIOC->MODER |= 0x00005500;
    GPIOC->OTYPER &= 0xFFFFFF0F;
    GPIOC->PUPDR &= 0xFFFF00FF;

    GPIOA->MODER &= 0xFF00FCFF;
    GPIOA->OTYPER &= 0xFFFFF0DF;
    GPIOA->PUPDR &= 0xFF00FCFF;

    GPIOA->PUPDR |= 0x00AA0000;
    GPIOA->MODER |= 0x00005100;

    GPIOB->MODER &= 0xFFFF0000;
    GPIOB->MODER |= 0x00005555;
    GPIOB->OTYPER &= 0xFFFFFF00;
    GPIOB->PUPDR &= 0xFFFF0000;

    GPIOA->ODR &= 0xFFBF;
    msdelay(50);
    LCD_cmd(0x38);
    LCD_cmd(0x01);
    LCD_cmd(0x0E);
    LCD_cmd(0x06);
    LCD_cmd(0x80);

    char msg[] = "Enter Key:";
    for(j=0; msg[j] != '\0'; j++) {
        LCD_disp(msg[j]);
    }

jump:
    GPIOC->BSRR = 0x000000F0;
    while((GPIOA->IDR & 0x00000F00) != 0) {}
    msdelay(10);

    while(1)
    {
        rowval = (GPIOA->IDR & 0x00000F00);
        if(rowval != 0)
        {
            msdelay(10);
            rowval = (GPIOA->IDR & 0x00000F00);
            if(rowval != 0)
            {
                break;
            }
        }
    }

    for(j = 0; j < 4; j++)
    {
        if(j==0)      { GPIOC->BSRR = 0x00E00010; }
        else if(j==1) { GPIOC->BSRR = 0x00D00020; }
        else if(j==2) { GPIOC->BSRR = 0x00B00040; }
        else if(j==3) { GPIOC->BSRR = 0x00700080; }

        rowval = (GPIOA->IDR & 0x00000F00);
        if(rowval != 0)
        {
            col_index = j;
            break;
        }
    }

    if (rowval == 0x0100) row_index = 0;
    else if (rowval == 0x0200) row_index = 1;
    else if (rowval == 0x0400) row_index = 2;
    else if (rowval == 0x0800) row_index = 3;

    key_char = keypad_map[row_index][col_index];

    LCD_cmd(0xC0);
    LCD_disp(key_char);
    LCD_disp(' ');

    goto jump;
}

void LCD_cmd(uint8_t comd) {
    GPIOB->ODR = (GPIOB->ODR & 0xFF00) | comd;
    GPIOA->ODR &= 0xFF7F;
    GPIOA->ODR |= 0x0010;
    msdelay(1);
    GPIOA->ODR &= 0xFFEF;
    msdelay(50);
}

void LCD_disp(unsigned char char1) {
    GPIOB->ODR = (GPIOB->ODR & 0xFF00) | char1;
    GPIOA->ODR |= 0x0080;
    GPIOA->ODR |= 0x0010;
    msdelay(1);
    GPIOA->ODR &= 0xFFEF;
    msdelay(50);
}

void msdelay(volatile uint32_t ms) {
    volatile uint32_t i, j;
    for (i = 0; i < ms; i++) {
        for (j = 0; j < 3180; j++) {
            __NOP();
        }
    }
}
